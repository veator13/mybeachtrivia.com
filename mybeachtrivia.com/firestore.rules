rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {



    function signedIn() { return request.auth != null; }
    function isSelf(uid) { return signedIn() && request.auth.uid == uid; }

    // Admin if claim 'admin' is true OR roles array contains admin/superadmin
    function isAdmin() {
      return signedIn() && (
        request.auth.token.admin == true ||
        (request.auth.token.roles != null &&
         request.auth.token.roles.hasAny(['admin','superadmin']))
      );
    }

    // Fields employees may edit on their own profile
    function selfAllowedKeys() {
      return [
        'firstName','lastName','nickname','dob',
        'phone','emergencyPhone','emergencyName','photoURL',
        'setupCompleted','updatedAt'
      ];
    }

    match /employees/{uid} {
      // Employee can read self; admin can read all
      allow read: if isSelf(uid) || isAdmin();

      // Create by admin only (you create employee docs via admin flow)
      allow create: if isAdmin();

      // Update: admin any; employee only allow-listed keys on self
      allow update: if isAdmin()
                 || (isSelf(uid) &&
                     request.resource.data.diff(resource.data)
                       .changedKeys().hasOnly(selfAllowedKeys()));

      // Delete by admin only
      allow delete: if isAdmin();
    }

    // (Leave your other collections' rules as they are)
  
    // playlists: hosts/admins can read all; signed-in can read published; writes admin-only


    // legacy music_bingo: same as playlists


    // games: players (anon or user) can read; hosts/admins control lifecycle
    match /games/{gameId} {
      allow read: if request.auth != null;
      allow create, update, delete: if request.auth != null && (
        request.auth.token.admin == true ||
        (request.auth.token.roles != null &&
         request.auth.token.roles.hasAny(['host','admin','superadmin'])) ||
        (request.auth.token.role != null &&
         (request.auth.token.role == 'host' || request.auth.token.role == 'admin' || request.auth.token.role == 'superadmin'))
      );
    }

    // playlists: allow read via claims OR employees profile; or published=true. Writes admin-only.
    match /playlists/{playlistId} {
      allow read: if request.auth != null && (
        // Claims path
        request.auth.token.admin == true ||
        (request.auth.token.roles != null && (
          'host' in request.auth.token.roles ||
          'admin' in request.auth.token.roles ||
          'superadmin' in request.auth.token.roles
        )) ||
        (request.auth.token.role != null && (
          request.auth.token.role == 'host' ||
          request.auth.token.role == 'admin' ||
          request.auth.token.role == 'superadmin'
        )) ||
        // Profile fallback
        (let prof = get(/databases/$(database)/documents/employees/$(request.auth.uid)).data;
         prof.roles != null && (
           'host' in prof.roles || 'admin' in prof.roles || 'superadmin' in prof.roles
         ))
      ) || (request.auth != null && resource.data.published == true);

      allow create, update, delete: if request.auth != null && (
        request.auth.token.admin == true ||
        (request.auth.token.roles != null && (
          'admin' in request.auth.token.roles || 'superadmin' in request.auth.token.roles
        )) ||
        (request.auth.token.role != null && (
          request.auth.token.role == 'admin' || request.auth.token.role == 'superadmin'
        ))
      );
    }

    // legacy music_bingo: same as playlists
    match /music_bingo/{playlistId} {
      allow read: if request.auth != null && (
        request.auth.token.admin == true ||
        (request.auth.token.roles != null && (
          'host' in request.auth.token.roles ||
          'admin' in request.auth.token.roles ||
          'superadmin' in request.auth.token.roles
        )) ||
        (request.auth.token.role != null && (
          request.auth.token.role == 'host' ||
          request.auth.token.role == 'admin' ||
          request.auth.token.role == 'superadmin'
        )) ||
        (let prof = get(/databases/$(database)/documents/employees/$(request.auth.uid)).data;
         prof.roles != null && (
           'host' in prof.roles || 'admin' in prof.roles || 'superadmin' in prof.roles
         ))
      ) || (request.auth != null && resource.data.published == true);

      allow create, update, delete: if request.auth != null && (
        request.auth.token.admin == true ||
        (request.auth.token.roles != null && (
          'admin' in request.auth.token.roles || 'superadmin' in request.auth.token.roles
        )) ||
        (request.auth.token.role != null && (
          request.auth.token.role == 'admin' || request.auth.token.role == 'superadmin'
        ))
      );
    }
}
    // playlists: hosts/admins can read all; signed-in can read published items; writes admin-only


    // legacy music_bingo collection: same as playlists


    // games: players (anon or user) can read; hosts/admins control lifecycle


}
